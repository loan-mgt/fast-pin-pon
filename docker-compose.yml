version: "3.9"

services:
  # keycloak_web:
  #   image: quay.io/keycloak/keycloak:latest
  #   container_name: keycloak_web
  #   command: start-dev --import-realm
  #   environment:
  #     KC_DB: ${KC_DB}
  #     KC_DB_URL: ${KC_DB_URL}
  #     KC_DB_USERNAME: ${POSTGRES_USER}
  #     KC_DB_PASSWORD: ${POSTGRES_PASSWORD}
  #     KC_HOSTNAME: ${KC_HOSTNAME}
  #     KC_HOSTNAME_PORT: ${KC_HOSTNAME_PORT}
  #     KC_HOSTNAME_STRICT: false
  #     KC_HOSTNAME_STRICT_HTTPS: false
  #     KC_LOG_LEVEL: info
  #     KC_METRICS_ENABLED: true
  #     KC_HEALTH_ENABLED: true

  #     # On utilise des noms "custom" que seul votre JSON connait.
  #     MY_ADMIN_USER: ${KC_BOOTSTRAP_ADMIN_USERNAME}
  #     MY_ADMIN_PASS: ${KC_BOOTSTRAP_ADMIN_PASSWORD}
  #     MY_ADMIN_EMAIL: ${MY_ADMIN_EMAIL}
  #     MY_ADMIN_FNAME: ${MY_ADMIN_FNAME}
  #     MY_ADMIN_LNAME: ${MY_ADMIN_LNAME}

  #     JAVA_OPTS_APPEND: -Dkeycloak.migration.replace-placeholders=true
    
  #   depends_on:
  #     - keycloakdb
  #   volumes:
  #     - ${KEYCLOAK_IMPORT_DIR}/realm-export.json:/opt/keycloak/data/import/realm-export.json
  #     - ${KEYCLOAK_IMPORT_DIR}/realm-export-sdmis.json:/opt/keycloak/data/import/realm-export-sdmis.json
  #   ports:
  #     - 8080:8080

  # keycloakdb:
  #   image: postgres:16
  #   volumes:
  #     - keycloak_postgres_data:/var/lib/postgresql/data
  #   environment:
  #     POSTGRES_DB: ${POSTGRES_DB}
  #     POSTGRES_USER: ${POSTGRES_USER}
  #     POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
  

  api:
    build:
      context: ./api
      dockerfile: Dockerfile
    container_name: fast-pin-pon-api
    env_file:
      - .env
    environment:
      - PORT=9031
    depends_on:
      postgres:
        condition: service_healthy
    networks:
      - internal
    logging:
      driver: "json-file"
      options:
        max-size: "100m"
        max-file: "3"

  postgres:
    build:
      context: ./database
      dockerfile: Dockerfile
    container_name: fast-pin-pon-postgres
    restart: unless-stopped
    environment:
      POSTGRES_DB: fastpinpon
      POSTGRES_USER: fastpinpon
      POSTGRES_PASSWORD: fastpinpon
    volumes:
      - postgres_data:/var/lib/postgresql
    networks:
      - internal
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U fastpinpon -d fastpinpon"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Bridge API <-> micro:bit
  # Récupère les unités depuis l'API et les envoie au micro:bit via USB
  bridge:
    build:
      context: ./network
      dockerfile: Dockerfile
    container_name: fast-pin-pon-bridge
    environment:
      - API_URL=https://api.fast-pin-pon.4loop.org
      - INTERVAL=5
      - BAUD_RATE=115200
    depends_on:
      - api
    networks:
      - internal
    # Pour accéder au micro:bit connecté en USB, décommenter:
    # devices:
    #   - /dev/ttyACM0:/dev/ttyACM0  # Linux
    #   # - /dev/tty.usbmodem*:/dev/tty.usbmodem*  # macOS (ne fonctionne pas en Docker)
    # privileged: true
    restart: unless-stopped

networks:
  internal:
    driver: bridge

volumes:
  postgres_data:
  keycloak_postgres_data:

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: dispatch_candidates.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getInterventionForDispatch = `-- name: GetInterventionForDispatch :one

SELECT 
    i.id AS intervention_id,
    i.event_id,
    i.status AS intervention_status,
    i.priority,
    i.decision_mode,
    e.title AS event_title,
    e.severity AS event_severity,
    e.event_type_code,
    et.recommended_unit_types,
    (ST_X(e.location::geometry))::double precision AS longitude,
    (ST_Y(e.location::geometry))::double precision AS latitude
FROM interventions i
JOIN events e ON i.event_id = e.id
JOIN event_types et ON e.event_type_code = et.code
WHERE i.id = $1
`

type GetInterventionForDispatchRow struct {
	InterventionID       pgtype.UUID        `json:"intervention_id"`
	EventID              pgtype.UUID        `json:"event_id"`
	InterventionStatus   InterventionStatus `json:"intervention_status"`
	Priority             int32              `json:"priority"`
	DecisionMode         DecisionMode       `json:"decision_mode"`
	EventTitle           string             `json:"event_title"`
	EventSeverity        int32              `json:"event_severity"`
	EventTypeCode        string             `json:"event_type_code"`
	RecommendedUnitTypes []string           `json:"recommended_unit_types"`
	Longitude            float64            `json:"longitude"`
	Latitude             float64            `json:"latitude"`
}

// =============================================================================
// Dispatch Candidate Queries
// Optimized queries for finding and scoring candidate units for dispatch
// =============================================================================
// Fetches intervention details needed for dispatch, including event location
func (q *Queries) GetInterventionForDispatch(ctx context.Context, id pgtype.UUID) (GetInterventionForDispatchRow, error) {
	row := q.db.QueryRow(ctx, getInterventionForDispatch, id)
	var i GetInterventionForDispatchRow
	err := row.Scan(
		&i.InterventionID,
		&i.EventID,
		&i.InterventionStatus,
		&i.Priority,
		&i.DecisionMode,
		&i.EventTitle,
		&i.EventSeverity,
		&i.EventTypeCode,
		&i.RecommendedUnitTypes,
		&i.Longitude,
		&i.Latitude,
	)
	return i, err
}

const getUnitsAtBase = `-- name: GetUnitsAtBase :one
SELECT 
    COUNT(*) FILTER (WHERE status = 'available')::bigint AS available_count,
    COUNT(*)::bigint AS total_count
FROM units
WHERE home_base = $1
`

type GetUnitsAtBaseRow struct {
	AvailableCount int64 `json:"available_count"`
	TotalCount     int64 `json:"total_count"`
}

// Count available units at a specific base (for coverage calculations)
func (q *Queries) GetUnitsAtBase(ctx context.Context, homeBase *string) (GetUnitsAtBaseRow, error) {
	row := q.db.QueryRow(ctx, getUnitsAtBase, homeBase)
	var i GetUnitsAtBaseRow
	err := row.Scan(&i.AvailableCount, &i.TotalCount)
	return i, err
}

const listDispatchCandidates = `-- name: ListDispatchCandidates :many
SELECT 
    u.id,
    u.call_sign,
    u.unit_type_code,
    u.home_base,
    u.status,
    (ST_X(u.location::geometry))::double precision AS longitude,
    (ST_Y(u.location::geometry))::double precision AS latitude,
    a.id AS current_assignment_id,
    a.intervention_id AS current_intervention_id,
    ce.severity AS current_intervention_severity,
    ci.priority AS current_intervention_priority,
    -- Estimate travel time from distance (assume 50 km/h = 13.89 m/s average speed)
    (ST_Distance(u.location, e.location) / 13.89)::double precision AS travel_time_seconds,
    ST_Distance(u.location, e.location)::double precision AS distance_meters,
    (SELECT COUNT(*) FROM units u2 
     WHERE u2.home_base = u.home_base 
       AND u2.status = 'available' 
       AND u2.id != u.id)::int AS other_units_at_base
FROM units u
CROSS JOIN (
    SELECT ev.location
    FROM interventions iv
    JOIN events ev ON iv.event_id = ev.id
    WHERE iv.id = $1
) e
LEFT JOIN intervention_assignments a 
    ON a.unit_id = u.id AND a.status = 'dispatched'
LEFT JOIN interventions ci 
    ON a.intervention_id = ci.id
LEFT JOIN events ce
    ON ci.event_id = ce.id
WHERE u.status IN ('available', 'under_way')
  AND u.location IS NOT NULL
  AND ($2::text[] IS NULL OR u.unit_type_code = ANY($2::text[]))
ORDER BY ST_Distance(u.location, e.location) ASC
LIMIT $3::int
`

type ListDispatchCandidatesParams struct {
	InterventionID pgtype.UUID `json:"intervention_id"`
	UnitTypes      []string    `json:"unit_types"`
	MaxCandidates  int32       `json:"max_candidates"`
}

type ListDispatchCandidatesRow struct {
	ID                          pgtype.UUID `json:"id"`
	CallSign                    string      `json:"call_sign"`
	UnitTypeCode                string      `json:"unit_type_code"`
	HomeBase                    *string     `json:"home_base"`
	Status                      UnitStatus  `json:"status"`
	Longitude                   float64     `json:"longitude"`
	Latitude                    float64     `json:"latitude"`
	CurrentAssignmentID         pgtype.UUID `json:"current_assignment_id"`
	CurrentInterventionID       pgtype.UUID `json:"current_intervention_id"`
	CurrentInterventionSeverity *int32      `json:"current_intervention_severity"`
	CurrentInterventionPriority *int32      `json:"current_intervention_priority"`
	TravelTimeSeconds           float64     `json:"travel_time_seconds"`
	DistanceMeters              float64     `json:"distance_meters"`
	OtherUnitsAtBase            int32       `json:"other_units_at_base"`
}

// Finds candidate units for dispatch using distance-based estimation
// Returns units sorted by estimated travel time, includes current assignment info for preemption
// Note: For precise routing, use the dedicated routing endpoint
func (q *Queries) ListDispatchCandidates(ctx context.Context, arg ListDispatchCandidatesParams) ([]ListDispatchCandidatesRow, error) {
	rows, err := q.db.Query(ctx, listDispatchCandidates, arg.InterventionID, arg.UnitTypes, arg.MaxCandidates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDispatchCandidatesRow
	for rows.Next() {
		var i ListDispatchCandidatesRow
		if err := rows.Scan(
			&i.ID,
			&i.CallSign,
			&i.UnitTypeCode,
			&i.HomeBase,
			&i.Status,
			&i.Longitude,
			&i.Latitude,
			&i.CurrentAssignmentID,
			&i.CurrentInterventionID,
			&i.CurrentInterventionSeverity,
			&i.CurrentInterventionPriority,
			&i.TravelTimeSeconds,
			&i.DistanceMeters,
			&i.OtherUnitsAtBase,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingInterventions = `-- name: ListPendingInterventions :many
SELECT 
    i.id AS intervention_id,
    i.event_id,
    i.status AS intervention_status,
    i.priority,
    i.created_at,
    e.severity AS event_severity,
    e.event_type_code,
    et.recommended_unit_types,
    (ST_X(e.location::geometry))::double precision AS longitude,
    (ST_Y(e.location::geometry))::double precision AS latitude,
    (SELECT COUNT(*) FROM intervention_assignments ia WHERE ia.intervention_id = i.id AND ia.status IN ('dispatched', 'arrived'))::bigint AS assigned_units_count
FROM interventions i
JOIN events e ON i.event_id = e.id
JOIN event_types et ON e.event_type_code = et.code
WHERE i.status = 'created'
ORDER BY e.severity DESC, i.created_at ASC
`

type ListPendingInterventionsRow struct {
	InterventionID       pgtype.UUID        `json:"intervention_id"`
	EventID              pgtype.UUID        `json:"event_id"`
	InterventionStatus   InterventionStatus `json:"intervention_status"`
	Priority             int32              `json:"priority"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	EventSeverity        int32              `json:"event_severity"`
	EventTypeCode        string             `json:"event_type_code"`
	RecommendedUnitTypes []string           `json:"recommended_unit_types"`
	Longitude            float64            `json:"longitude"`
	Latitude             float64            `json:"latitude"`
	AssignedUnitsCount   int64              `json:"assigned_units_count"`
}

// Lists interventions awaiting dispatch, ordered by severity and age
func (q *Queries) ListPendingInterventions(ctx context.Context) ([]ListPendingInterventionsRow, error) {
	rows, err := q.db.Query(ctx, listPendingInterventions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPendingInterventionsRow
	for rows.Next() {
		var i ListPendingInterventionsRow
		if err := rows.Scan(
			&i.InterventionID,
			&i.EventID,
			&i.InterventionStatus,
			&i.Priority,
			&i.CreatedAt,
			&i.EventSeverity,
			&i.EventTypeCode,
			&i.RecommendedUnitTypes,
			&i.Longitude,
			&i.Latitude,
			&i.AssignedUnitsCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const releaseAssignment = `-- name: ReleaseAssignment :exec
UPDATE intervention_assignments
SET 
    status = 'released',
    released_at = NOW()
WHERE id = $1
`

// Release a unit from its current assignment (for preemption)
func (q *Queries) ReleaseAssignment(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, releaseAssignment, id)
	return err
}

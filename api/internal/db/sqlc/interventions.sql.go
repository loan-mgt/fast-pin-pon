// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: interventions.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAssignment = `-- name: CreateAssignment :one
INSERT INTO intervention_assignments (
    intervention_id,
    unit_id,
    role,
    status
) VALUES (
    $1,
    $2,
    $3,
    COALESCE($4::assignment_status, 'dispatched')
) RETURNING
    id,
    intervention_id,
    unit_id,
    role,
    status,
    dispatched_at,
    arrived_at,
    released_at
`

type CreateAssignmentParams struct {
	InterventionID pgtype.UUID      `json:"intervention_id"`
	UnitID         pgtype.UUID      `json:"unit_id"`
	Role           *string          `json:"role"`
	Status         AssignmentStatus `json:"status"`
}

func (q *Queries) CreateAssignment(ctx context.Context, arg CreateAssignmentParams) (InterventionAssignment, error) {
	row := q.db.QueryRow(ctx, createAssignment,
		arg.InterventionID,
		arg.UnitID,
		arg.Role,
		arg.Status,
	)
	var i InterventionAssignment
	err := row.Scan(
		&i.ID,
		&i.InterventionID,
		&i.UnitID,
		&i.Role,
		&i.Status,
		&i.DispatchedAt,
		&i.ArrivedAt,
		&i.ReleasedAt,
	)
	return i, err
}

const createIntervention = `-- name: CreateIntervention :one
INSERT INTO interventions (
    event_id,
    status,
    priority,
    decision_mode,
    created_by,
    notes
) VALUES (
    $1,
    COALESCE($2::intervention_status, 'created'),
    COALESCE($3::int, 3),
    COALESCE($4::decision_mode, 'manual'),
    $5,
    $6
) RETURNING
    id,
    event_id,
    status,
    priority,
    decision_mode,
    created_by,
    notes,
    created_at,
    started_at,
    completed_at
`

type CreateInterventionParams struct {
	EventID      pgtype.UUID        `json:"event_id"`
	Status       InterventionStatus `json:"status"`
	Priority     int32              `json:"priority"`
	DecisionMode DecisionMode       `json:"decision_mode"`
	CreatedBy    *string            `json:"created_by"`
	Notes        *string            `json:"notes"`
}

func (q *Queries) CreateIntervention(ctx context.Context, arg CreateInterventionParams) (Intervention, error) {
	row := q.db.QueryRow(ctx, createIntervention,
		arg.EventID,
		arg.Status,
		arg.Priority,
		arg.DecisionMode,
		arg.CreatedBy,
		arg.Notes,
	)
	var i Intervention
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.Status,
		&i.Priority,
		&i.DecisionMode,
		&i.CreatedBy,
		&i.Notes,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getIntervention = `-- name: GetIntervention :one
SELECT
    id,
    event_id,
    status,
    priority,
    decision_mode,
    created_by,
    notes,
    created_at,
    started_at,
    completed_at
FROM interventions
WHERE id = $1
`

func (q *Queries) GetIntervention(ctx context.Context, id pgtype.UUID) (Intervention, error) {
	row := q.db.QueryRow(ctx, getIntervention, id)
	var i Intervention
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.Status,
		&i.Priority,
		&i.DecisionMode,
		&i.CreatedBy,
		&i.Notes,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}

const listAssignmentsByIntervention = `-- name: ListAssignmentsByIntervention :many
SELECT
    ia.id,
    ia.intervention_id,
    ia.unit_id,
    ia.role,
    ia.status,
    ia.dispatched_at,
    ia.arrived_at,
    ia.released_at,
	u.call_sign,
	u.unit_type_code,
	u.status AS unit_status,
	u.home_base,
	u.microbit_id,
	(COALESCE(ST_X(u.location::geometry)::double precision, 0::double precision))::double precision AS longitude,
	(COALESCE(ST_Y(u.location::geometry)::double precision, 0::double precision))::double precision AS latitude,
	u.last_contact_at,
	u.created_at,
	u.updated_at
FROM intervention_assignments ia
JOIN units u ON u.id = ia.unit_id
WHERE ia.intervention_id = $1
ORDER BY ia.dispatched_at DESC
`

type ListAssignmentsByInterventionRow struct {
	ID             pgtype.UUID        `json:"id"`
	InterventionID pgtype.UUID        `json:"intervention_id"`
	UnitID         pgtype.UUID        `json:"unit_id"`
	Role           *string            `json:"role"`
	Status         AssignmentStatus   `json:"status"`
	DispatchedAt   pgtype.Timestamptz `json:"dispatched_at"`
	ArrivedAt      pgtype.Timestamptz `json:"arrived_at"`
	ReleasedAt     pgtype.Timestamptz `json:"released_at"`
	CallSign       string             `json:"call_sign"`
	UnitTypeCode   string             `json:"unit_type_code"`
	UnitStatus     UnitStatus         `json:"unit_status"`
	HomeBase       *string            `json:"home_base"`
	MicrobitID     *string            `json:"microbit_id"`
	Longitude      float64            `json:"longitude"`
	Latitude       float64            `json:"latitude"`
	LastContactAt  pgtype.Timestamptz `json:"last_contact_at"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) ListAssignmentsByIntervention(ctx context.Context, interventionID pgtype.UUID) ([]ListAssignmentsByInterventionRow, error) {
	rows, err := q.db.Query(ctx, listAssignmentsByIntervention, interventionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAssignmentsByInterventionRow
	for rows.Next() {
		var i ListAssignmentsByInterventionRow
		if err := rows.Scan(
			&i.ID,
			&i.InterventionID,
			&i.UnitID,
			&i.Role,
			&i.Status,
			&i.DispatchedAt,
			&i.ArrivedAt,
			&i.ReleasedAt,
			&i.CallSign,
			&i.UnitTypeCode,
			&i.UnitStatus,
			&i.HomeBase,
			&i.MicrobitID,
			&i.Longitude,
			&i.Latitude,
			&i.LastContactAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnitsAssignedToEvent = `-- name: ListUnitsAssignedToEvent :many
SELECT
	u.id,
	u.call_sign,
	u.unit_type_code,
	u.home_base,
	u.status,
	u.microbit_id,
	(COALESCE(ST_X(u.location::geometry)::double precision, 0::double precision))::double precision AS longitude,
	(COALESCE(ST_Y(u.location::geometry)::double precision, 0::double precision))::double precision AS latitude,
	u.last_contact_at,
	u.created_at,
	u.updated_at
FROM intervention_assignments ia
JOIN interventions i ON ia.intervention_id = i.id
JOIN units u ON ia.unit_id = u.id
WHERE i.event_id = $1 AND ia.released_at IS NULL
ORDER BY ia.dispatched_at DESC
`

type ListUnitsAssignedToEventRow struct {
	ID           pgtype.UUID        `json:"id"`
	CallSign     string             `json:"call_sign"`
	UnitTypeCode string             `json:"unit_type_code"`
	HomeBase     *string            `json:"home_base"`
	Status       UnitStatus         `json:"status"`
	MicrobitID   *string            `json:"microbit_id"`
	Longitude    float64            `json:"longitude"`
	Latitude     float64            `json:"latitude"`
	LastContact  pgtype.Timestamptz `json:"last_contact_at"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) ListUnitsAssignedToEvent(ctx context.Context, eventID pgtype.UUID) ([]ListUnitsAssignedToEventRow, error) {
	rows, err := q.db.Query(ctx, listUnitsAssignedToEvent, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUnitsAssignedToEventRow
	for rows.Next() {
		var i ListUnitsAssignedToEventRow
		if err := rows.Scan(
			&i.ID,
			&i.CallSign,
			&i.UnitTypeCode,
			&i.HomeBase,
			&i.Status,
			&i.MicrobitID,
			&i.Longitude,
			&i.Latitude,
			&i.LastContact,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInterventionsByEvent = `-- name: ListInterventionsByEvent :many
SELECT
    id,
    event_id,
    status,
    priority,
    decision_mode,
    created_by,
    notes,
    created_at,
    started_at,
    completed_at
FROM interventions
WHERE event_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListInterventionsByEvent(ctx context.Context, eventID pgtype.UUID) ([]Intervention, error) {
	rows, err := q.db.Query(ctx, listInterventionsByEvent, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Intervention
	for rows.Next() {
		var i Intervention
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.Status,
			&i.Priority,
			&i.DecisionMode,
			&i.CreatedBy,
			&i.Notes,
			&i.CreatedAt,
			&i.StartedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAssignmentStatus = `-- name: UpdateAssignmentStatus :one
UPDATE intervention_assignments
SET
    status = $2::assignment_status,
    arrived_at = CASE WHEN $2::assignment_status = 'arrived' THEN NOW() ELSE arrived_at END,
    released_at = CASE WHEN $2::assignment_status = 'released' THEN NOW() ELSE released_at END
WHERE id = $1
RETURNING
    id,
    intervention_id,
    unit_id,
    role,
    status,
    dispatched_at,
    arrived_at,
    released_at
`

type UpdateAssignmentStatusParams struct {
	ID      pgtype.UUID      `json:"id"`
	Column2 AssignmentStatus `json:"column_2"`
}

func (q *Queries) UpdateAssignmentStatus(ctx context.Context, arg UpdateAssignmentStatusParams) (InterventionAssignment, error) {
	row := q.db.QueryRow(ctx, updateAssignmentStatus, arg.ID, arg.Column2)
	var i InterventionAssignment
	err := row.Scan(
		&i.ID,
		&i.InterventionID,
		&i.UnitID,
		&i.Role,
		&i.Status,
		&i.DispatchedAt,
		&i.ArrivedAt,
		&i.ReleasedAt,
	)
	return i, err
}

const updateInterventionStatus = `-- name: UpdateInterventionStatus :one
UPDATE interventions
SET
    status = $2::intervention_status,
    started_at = CASE WHEN $2::intervention_status = 'on_site' AND started_at IS NULL THEN NOW() ELSE started_at END,
    completed_at = CASE WHEN $2::intervention_status = 'completed' THEN NOW() ELSE completed_at END
WHERE id = $1
RETURNING
    id,
    event_id,
    status,
    priority,
    decision_mode,
    created_by,
    notes,
    created_at,
    started_at,
    completed_at
`

type UpdateInterventionStatusParams struct {
	ID      pgtype.UUID        `json:"id"`
	Column2 InterventionStatus `json:"column_2"`
}

func (q *Queries) UpdateInterventionStatus(ctx context.Context, arg UpdateInterventionStatusParams) (Intervention, error) {
	row := q.db.QueryRow(ctx, updateInterventionStatus, arg.ID, arg.Column2)
	var i Intervention
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.Status,
		&i.Priority,
		&i.DecisionMode,
		&i.CreatedBy,
		&i.Notes,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}

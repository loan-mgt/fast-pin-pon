// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: routing.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteUnitRoute = `-- name: DeleteUnitRoute :exec
DELETE FROM unit_routes WHERE unit_id = $1
`

// Deletes a unit's route (called when unit status changes)
func (q *Queries) DeleteUnitRoute(ctx context.Context, unitID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteUnitRoute, unitID)
	return err
}

const getRouteCalculationData = `-- name: GetRouteCalculationData :one
SELECT
    u.id AS unit_id,
    (COALESCE(ST_X(u.location::geometry)::double precision, 0::double precision))::double precision AS unit_lon,
    (COALESCE(ST_Y(u.location::geometry)::double precision, 0::double precision))::double precision AS unit_lat,
    e.id AS event_id,
    ST_X(e.location::geometry)::double precision AS event_lon,
    ST_Y(e.location::geometry)::double precision AS event_lat
FROM interventions i
JOIN events e ON e.id = i.event_id
JOIN units u ON u.id = $1
WHERE i.id = $2
`

type GetRouteCalculationDataParams struct {
	UnitID         pgtype.UUID `json:"unit_id"`
	InterventionID pgtype.UUID `json:"intervention_id"`
}

type GetRouteCalculationDataRow struct {
	UnitID   pgtype.UUID `json:"unit_id"`
	UnitLon  float64     `json:"unit_lon"`
	UnitLat  float64     `json:"unit_lat"`
	EventID  pgtype.UUID `json:"event_id"`
	EventLon float64     `json:"event_lon"`
	EventLat float64     `json:"event_lat"`
}

// Gets all data needed to calculate a route for an assignment (unit position + event destination)
// Single query instead of 3 separate queries
func (q *Queries) GetRouteCalculationData(ctx context.Context, arg GetRouteCalculationDataParams) (GetRouteCalculationDataRow, error) {
	row := q.db.QueryRow(ctx, getRouteCalculationData, arg.UnitID, arg.InterventionID)
	var i GetRouteCalculationDataRow
	err := row.Scan(
		&i.UnitID,
		&i.UnitLon,
		&i.UnitLat,
		&i.EventID,
		&i.EventLon,
		&i.EventLat,
	)
	return i, err
}

const getRoutePosition = `-- name: GetRoutePosition :one
SELECT
    ST_X(ST_LineInterpolatePoint(route_geometry, LEAST($1::double precision / 100.0, 1.0)))::double precision AS lon,
    ST_Y(ST_LineInterpolatePoint(route_geometry, LEAST($1::double precision / 100.0, 1.0)))::double precision AS lat
FROM unit_routes
WHERE unit_id = $2
`

type GetRoutePositionParams struct {
	ProgressPercent float64     `json:"progress_percent"`
	UnitID          pgtype.UUID `json:"unit_id"`
}

type GetRoutePositionRow struct {
	Lon float64 `json:"lon"`
	Lat float64 `json:"lat"`
}

// Gets just the interpolated position for a given progress (for simulation)
func (q *Queries) GetRoutePosition(ctx context.Context, arg GetRoutePositionParams) (GetRoutePositionRow, error) {
	row := q.db.QueryRow(ctx, getRoutePosition, arg.ProgressPercent, arg.UnitID)
	var i GetRoutePositionRow
	err := row.Scan(&i.Lon, &i.Lat)
	return i, err
}

const getUnitRoute = `-- name: GetUnitRoute :one
SELECT 
    unit_id,
    intervention_id,
    ST_AsGeoJSON(route_geometry)::text AS route_geojson,
    route_length_meters,
    estimated_duration_seconds,
    progress_percent,
    -- Current position interpolated along the route
    ST_X(ST_LineInterpolatePoint(route_geometry, LEAST(progress_percent / 100.0, 1.0)))::double precision AS current_lon,
    ST_Y(ST_LineInterpolatePoint(route_geometry, LEAST(progress_percent / 100.0, 1.0)))::double precision AS current_lat,
    -- Remaining distance and time
    (route_length_meters * (1.0 - progress_percent / 100.0))::double precision AS remaining_meters,
    (estimated_duration_seconds * (1.0 - progress_percent / 100.0))::double precision AS remaining_seconds,
    created_at,
    updated_at
FROM unit_routes
WHERE unit_id = $1
`

type GetUnitRouteRow struct {
	UnitID                   pgtype.UUID        `json:"unit_id"`
	InterventionID           pgtype.UUID        `json:"intervention_id"`
	RouteGeojson             string             `json:"route_geojson"`
	RouteLengthMeters        float64            `json:"route_length_meters"`
	EstimatedDurationSeconds float64            `json:"estimated_duration_seconds"`
	ProgressPercent          float64            `json:"progress_percent"`
	CurrentLon               float64            `json:"current_lon"`
	CurrentLat               float64            `json:"current_lat"`
	RemainingMeters          float64            `json:"remaining_meters"`
	RemainingSeconds         float64            `json:"remaining_seconds"`
	CreatedAt                pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                pgtype.Timestamptz `json:"updated_at"`
}

// Gets a unit's route with current position interpolated from progress
func (q *Queries) GetUnitRoute(ctx context.Context, unitID pgtype.UUID) (GetUnitRouteRow, error) {
	row := q.db.QueryRow(ctx, getUnitRoute, unitID)
	var i GetUnitRouteRow
	err := row.Scan(
		&i.UnitID,
		&i.InterventionID,
		&i.RouteGeojson,
		&i.RouteLengthMeters,
		&i.EstimatedDurationSeconds,
		&i.ProgressPercent,
		&i.CurrentLon,
		&i.CurrentLat,
		&i.RemainingMeters,
		&i.RemainingSeconds,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const saveUnitRoute = `-- name: SaveUnitRoute :one

INSERT INTO unit_routes (unit_id, intervention_id, route_geometry, route_length_meters, estimated_duration_seconds, progress_percent)
VALUES (
    $1, 
    $2, 
    ST_GeomFromGeoJSON($3), 
    $4, 
    $5,
    0
)
ON CONFLICT (unit_id) DO UPDATE SET
    intervention_id = EXCLUDED.intervention_id,
    route_geometry = EXCLUDED.route_geometry,
    route_length_meters = EXCLUDED.route_length_meters,
    estimated_duration_seconds = EXCLUDED.estimated_duration_seconds,
    progress_percent = 0,
    updated_at = NOW()
RETURNING 
    unit_id,
    intervention_id,
    ST_AsGeoJSON(route_geometry)::text AS route_geojson,
    route_length_meters,
    estimated_duration_seconds,
    progress_percent,
    created_at,
    updated_at
`

type SaveUnitRouteParams struct {
	UnitID                   pgtype.UUID `json:"unit_id"`
	InterventionID           pgtype.UUID `json:"intervention_id"`
	RouteGeojson             interface{} `json:"route_geojson"`
	RouteLengthMeters        float64     `json:"route_length_meters"`
	EstimatedDurationSeconds float64     `json:"estimated_duration_seconds"`
}

type SaveUnitRouteRow struct {
	UnitID                   pgtype.UUID        `json:"unit_id"`
	InterventionID           pgtype.UUID        `json:"intervention_id"`
	RouteGeojson             string             `json:"route_geojson"`
	RouteLengthMeters        float64            `json:"route_length_meters"`
	EstimatedDurationSeconds float64            `json:"estimated_duration_seconds"`
	ProgressPercent          float64            `json:"progress_percent"`
	CreatedAt                pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                pgtype.Timestamptz `json:"updated_at"`
}

// =============================================================================
// Routing Queries - pgRouting + Unit Route Storage
// =============================================================================
// Saves or updates a route for a unit (upsert)
func (q *Queries) SaveUnitRoute(ctx context.Context, arg SaveUnitRouteParams) (SaveUnitRouteRow, error) {
	row := q.db.QueryRow(ctx, saveUnitRoute,
		arg.UnitID,
		arg.InterventionID,
		arg.RouteGeojson,
		arg.RouteLengthMeters,
		arg.EstimatedDurationSeconds,
	)
	var i SaveUnitRouteRow
	err := row.Scan(
		&i.UnitID,
		&i.InterventionID,
		&i.RouteGeojson,
		&i.RouteLengthMeters,
		&i.EstimatedDurationSeconds,
		&i.ProgressPercent,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateRouteProgress = `-- name: UpdateRouteProgress :one
UPDATE unit_routes
SET 
    progress_percent = $1,
    updated_at = NOW()
WHERE unit_id = $2
RETURNING 
    unit_id,
    progress_percent,
    ST_X(ST_LineInterpolatePoint(route_geometry, LEAST(progress_percent / 100.0, 1.0)))::double precision AS current_lon,
    ST_Y(ST_LineInterpolatePoint(route_geometry, LEAST(progress_percent / 100.0, 1.0)))::double precision AS current_lat,
    (route_length_meters * (1.0 - progress_percent / 100.0))::double precision AS remaining_meters,
    (estimated_duration_seconds * (1.0 - progress_percent / 100.0))::double precision AS remaining_seconds
`

type UpdateRouteProgressParams struct {
	ProgressPercent float64     `json:"progress_percent"`
	UnitID          pgtype.UUID `json:"unit_id"`
}

type UpdateRouteProgressRow struct {
	UnitID           pgtype.UUID `json:"unit_id"`
	ProgressPercent  float64     `json:"progress_percent"`
	CurrentLon       float64     `json:"current_lon"`
	CurrentLat       float64     `json:"current_lat"`
	RemainingMeters  float64     `json:"remaining_meters"`
	RemainingSeconds float64     `json:"remaining_seconds"`
}

// Updates the progress percentage and returns the new interpolated position
func (q *Queries) UpdateRouteProgress(ctx context.Context, arg UpdateRouteProgressParams) (UpdateRouteProgressRow, error) {
	row := q.db.QueryRow(ctx, updateRouteProgress, arg.ProgressPercent, arg.UnitID)
	var i UpdateRouteProgressRow
	err := row.Scan(
		&i.UnitID,
		&i.ProgressPercent,
		&i.CurrentLon,
		&i.CurrentLat,
		&i.RemainingMeters,
		&i.RemainingSeconds,
	)
	return i, err
}

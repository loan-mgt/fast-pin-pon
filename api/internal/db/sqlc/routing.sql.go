// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: routing.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteUnitRoute = `-- name: DeleteUnitRoute :exec
DELETE FROM unit_routes WHERE unit_id = $1
`

// Deletes a unit's route (called when unit status changes)
func (q *Queries) DeleteUnitRoute(ctx context.Context, unitID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteUnitRoute, unitID)
	return err
}

const getActiveRouteRepairData = `-- name: GetActiveRouteRepairData :one
SELECT
        ia.intervention_id,
        u.id AS unit_id,
        COALESCE(ST_X(u.location::geometry), 0)::float8 AS unit_lon,
        COALESCE(ST_Y(u.location::geometry), 0)::float8 AS unit_lat,
        e.id AS event_id,
        ST_X(e.location::geometry)::float8 AS event_lon,
        ST_Y(e.location::geometry)::float8 AS event_lat
FROM intervention_assignments ia
JOIN interventions i ON i.id = ia.intervention_id
JOIN events e ON e.id = i.event_id
JOIN units u ON u.id = ia.unit_id
WHERE ia.unit_id = $1
    AND ia.released_at IS NULL
    AND ia.status IN ('dispatched', 'arrived')
ORDER BY ia.dispatched_at DESC
LIMIT 1
`

type GetActiveRouteRepairDataRow struct {
	InterventionID pgtype.UUID `json:"intervention_id"`
	UnitID         pgtype.UUID `json:"unit_id"`
	UnitLon        float64     `json:"unit_lon"`
	UnitLat        float64     `json:"unit_lat"`
	EventID        pgtype.UUID `json:"event_id"`
	EventLon       float64     `json:"event_lon"`
	EventLat       float64     `json:"event_lat"`
}

// Finds the latest active assignment for a unit to repair a missing route
// Returns both the intervention id and coordinates needed for routing
func (q *Queries) GetActiveRouteRepairData(ctx context.Context, unitID pgtype.UUID) (GetActiveRouteRepairDataRow, error) {
	row := q.db.QueryRow(ctx, getActiveRouteRepairData, unitID)
	var i GetActiveRouteRepairDataRow
	err := row.Scan(
		&i.InterventionID,
		&i.UnitID,
		&i.UnitLon,
		&i.UnitLat,
		&i.EventID,
		&i.EventLon,
		&i.EventLat,
	)
	return i, err
}

const getRouteCalculationData = `-- name: GetRouteCalculationData :one
SELECT
    u.id AS unit_id,
    COALESCE(ST_X(u.location::geometry), 0)::float8 AS unit_lon,
    COALESCE(ST_Y(u.location::geometry), 0)::float8 AS unit_lat,
    e.id AS event_id,
    ST_X(e.location::geometry)::float8 AS event_lon,
    ST_Y(e.location::geometry)::float8 AS event_lat
FROM interventions i
JOIN events e ON e.id = i.event_id
JOIN units u ON u.id = $1
WHERE i.id = $2
`

type GetRouteCalculationDataParams struct {
	UnitID         pgtype.UUID `json:"unit_id"`
	InterventionID pgtype.UUID `json:"intervention_id"`
}

type GetRouteCalculationDataRow struct {
	UnitID   pgtype.UUID `json:"unit_id"`
	UnitLon  float64     `json:"unit_lon"`
	UnitLat  float64     `json:"unit_lat"`
	EventID  pgtype.UUID `json:"event_id"`
	EventLon float64     `json:"event_lon"`
	EventLat float64     `json:"event_lat"`
}

// Gets all data needed to calculate a route for an assignment (unit position + event destination)
func (q *Queries) GetRouteCalculationData(ctx context.Context, arg GetRouteCalculationDataParams) (GetRouteCalculationDataRow, error) {
	row := q.db.QueryRow(ctx, getRouteCalculationData, arg.UnitID, arg.InterventionID)
	var i GetRouteCalculationDataRow
	err := row.Scan(
		&i.UnitID,
		&i.UnitLon,
		&i.UnitLat,
		&i.EventID,
		&i.EventLon,
		&i.EventLat,
	)
	return i, err
}

const getRoutePosition = `-- name: GetRoutePosition :one
SELECT
    ST_X(ST_LineInterpolatePoint(route_geometry, $1 / 100.0))::float8 AS lon,
    ST_Y(ST_LineInterpolatePoint(route_geometry, $1 / 100.0))::float8 AS lat
FROM unit_routes
WHERE unit_id = $2
`

type GetRoutePositionParams struct {
	ProgressPercent interface{} `json:"progress_percent"`
	UnitID          pgtype.UUID `json:"unit_id"`
}

type GetRoutePositionRow struct {
	Lon float64 `json:"lon"`
	Lat float64 `json:"lat"`
}

// Gets just the interpolated position for a given progress (for simulation)
// Optimized: Removed redundant cast and LEAST call
func (q *Queries) GetRoutePosition(ctx context.Context, arg GetRoutePositionParams) (GetRoutePositionRow, error) {
	row := q.db.QueryRow(ctx, getRoutePosition, arg.ProgressPercent, arg.UnitID)
	var i GetRoutePositionRow
	err := row.Scan(&i.Lon, &i.Lat)
	return i, err
}

const getUnitRoute = `-- name: GetUnitRoute :one
SELECT 
    ur.unit_id,
    ur.intervention_id,
    ST_AsGeoJSON(ur.route_geometry)::text AS route_geojson,
    ur.route_length_meters,
    ur.estimated_duration_seconds,
    ur.progress_percent,
    -- Current position interpolated along the route
    ST_X(ST_LineInterpolatePoint(ur.route_geometry, ur.progress_percent / 100.0))::float8 AS current_lon,
    ST_Y(ST_LineInterpolatePoint(ur.route_geometry, ur.progress_percent / 100.0))::float8 AS current_lat,
    -- Remaining distance and time
    (ur.route_length_meters * (1.0 - ur.progress_percent / 100.0))::float8 AS remaining_meters,
    (ur.estimated_duration_seconds * (1.0 - ur.progress_percent / 100.0))::float8 AS remaining_seconds,
    ur.created_at,
    ur.updated_at,
    e.severity,
    COALESCE(e.auto_simulated, true) AS auto_simulated
FROM unit_routes ur
LEFT JOIN interventions i ON ur.intervention_id = i.id
LEFT JOIN events e ON i.event_id = e.id
WHERE ur.unit_id = $1
`

type GetUnitRouteRow struct {
	UnitID                   pgtype.UUID        `json:"unit_id"`
	InterventionID           pgtype.UUID        `json:"intervention_id"`
	RouteGeojson             string             `json:"route_geojson"`
	RouteLengthMeters        float64            `json:"route_length_meters"`
	EstimatedDurationSeconds float64            `json:"estimated_duration_seconds"`
	ProgressPercent          float64            `json:"progress_percent"`
	CurrentLon               float64            `json:"current_lon"`
	CurrentLat               float64            `json:"current_lat"`
	RemainingMeters          float64            `json:"remaining_meters"`
	RemainingSeconds         float64            `json:"remaining_seconds"`
	CreatedAt                pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                pgtype.Timestamptz `json:"updated_at"`
	Severity                 *int32             `json:"severity"`
	AutoSimulated            bool               `json:"auto_simulated"`
}

// Gets a unit's route with current position interpolated from progress
func (q *Queries) GetUnitRoute(ctx context.Context, unitID pgtype.UUID) (GetUnitRouteRow, error) {
	row := q.db.QueryRow(ctx, getUnitRoute, unitID)
	var i GetUnitRouteRow
	err := row.Scan(
		&i.UnitID,
		&i.InterventionID,
		&i.RouteGeojson,
		&i.RouteLengthMeters,
		&i.EstimatedDurationSeconds,
		&i.ProgressPercent,
		&i.CurrentLon,
		&i.CurrentLat,
		&i.RemainingMeters,
		&i.RemainingSeconds,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Severity,
		&i.AutoSimulated,
	)
	return i, err
}

const getUnitStationRouteData = `-- name: GetUnitStationRouteData :one

SELECT
    u.id AS unit_id,
    COALESCE(ST_X(u.location::geometry), 0)::float8 AS unit_lon,
    COALESCE(ST_Y(u.location::geometry), 0)::float8 AS unit_lat,
    l.id AS station_id,
    COALESCE(ST_X(l.location::geometry), 0)::float8 AS station_lon,
    COALESCE(ST_Y(l.location::geometry), 0)::float8 AS station_lat
FROM units u
JOIN locations l ON l.id = u.location_id
WHERE u.id = $1
`

type GetUnitStationRouteDataRow struct {
	UnitID     pgtype.UUID `json:"unit_id"`
	UnitLon    float64     `json:"unit_lon"`
	UnitLat    float64     `json:"unit_lat"`
	StationID  pgtype.UUID `json:"station_id"`
	StationLon float64     `json:"station_lon"`
	StationLat float64     `json:"station_lat"`
}

// NOTE: CalculateRoute is implemented as raw SQL in handlers_routing.go
// because sqlc cannot parse pgr_connectedComponents and other pgRouting functions
// Gets all data needed to calculate a route to the unit's home station
func (q *Queries) GetUnitStationRouteData(ctx context.Context, unitID pgtype.UUID) (GetUnitStationRouteDataRow, error) {
	row := q.db.QueryRow(ctx, getUnitStationRouteData, unitID)
	var i GetUnitStationRouteDataRow
	err := row.Scan(
		&i.UnitID,
		&i.UnitLon,
		&i.UnitLat,
		&i.StationID,
		&i.StationLon,
		&i.StationLat,
	)
	return i, err
}

const saveUnitRoute = `-- name: SaveUnitRoute :one

INSERT INTO unit_routes (unit_id, intervention_id, route_geometry, route_length_meters, estimated_duration_seconds, progress_percent)
VALUES (
    $1, 
    $2, 
    ST_GeomFromGeoJSON($3), 
    $4, 
    $5,
    0
)
ON CONFLICT (unit_id) DO UPDATE SET
    intervention_id = EXCLUDED.intervention_id,
    route_geometry = EXCLUDED.route_geometry,
    route_length_meters = EXCLUDED.route_length_meters,
    estimated_duration_seconds = EXCLUDED.estimated_duration_seconds,
    progress_percent = 0,
    updated_at = NOW()
RETURNING 
    unit_id,
    intervention_id,
    ST_AsGeoJSON(route_geometry)::text AS route_geojson,
    route_length_meters,
    estimated_duration_seconds,
    progress_percent,
    created_at,
    updated_at
`

type SaveUnitRouteParams struct {
	UnitID                   pgtype.UUID `json:"unit_id"`
	InterventionID           pgtype.UUID `json:"intervention_id"`
	RouteGeojson             interface{} `json:"route_geojson"`
	RouteLengthMeters        float64     `json:"route_length_meters"`
	EstimatedDurationSeconds float64     `json:"estimated_duration_seconds"`
}

type SaveUnitRouteRow struct {
	UnitID                   pgtype.UUID        `json:"unit_id"`
	InterventionID           pgtype.UUID        `json:"intervention_id"`
	RouteGeojson             string             `json:"route_geojson"`
	RouteLengthMeters        float64            `json:"route_length_meters"`
	EstimatedDurationSeconds float64            `json:"estimated_duration_seconds"`
	ProgressPercent          float64            `json:"progress_percent"`
	CreatedAt                pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                pgtype.Timestamptz `json:"updated_at"`
}

// =============================================================================
// Routing Queries - pgRouting + Unit Route Storage
// =============================================================================
// Saves or updates a route for a unit (upsert)
func (q *Queries) SaveUnitRoute(ctx context.Context, arg SaveUnitRouteParams) (SaveUnitRouteRow, error) {
	row := q.db.QueryRow(ctx, saveUnitRoute,
		arg.UnitID,
		arg.InterventionID,
		arg.RouteGeojson,
		arg.RouteLengthMeters,
		arg.EstimatedDurationSeconds,
	)
	var i SaveUnitRouteRow
	err := row.Scan(
		&i.UnitID,
		&i.InterventionID,
		&i.RouteGeojson,
		&i.RouteLengthMeters,
		&i.EstimatedDurationSeconds,
		&i.ProgressPercent,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateRouteProgress = `-- name: UpdateRouteProgress :one
UPDATE unit_routes
SET 
    progress_percent = $1,
    updated_at = NOW()
WHERE unit_id = $2
RETURNING 
    unit_id,
    progress_percent,
    ST_X(ST_LineInterpolatePoint(route_geometry, progress_percent / 100.0))::float8 AS current_lon,
    ST_Y(ST_LineInterpolatePoint(route_geometry, progress_percent / 100.0))::float8 AS current_lat,
    (route_length_meters * (1.0 - progress_percent / 100.0))::float8 AS remaining_meters,
    (estimated_duration_seconds * (1.0 - progress_percent / 100.0))::float8 AS remaining_seconds
`

type UpdateRouteProgressParams struct {
	ProgressPercent float64     `json:"progress_percent"`
	UnitID          pgtype.UUID `json:"unit_id"`
}

type UpdateRouteProgressRow struct {
	UnitID           pgtype.UUID `json:"unit_id"`
	ProgressPercent  float64     `json:"progress_percent"`
	CurrentLon       float64     `json:"current_lon"`
	CurrentLat       float64     `json:"current_lat"`
	RemainingMeters  float64     `json:"remaining_meters"`
	RemainingSeconds float64     `json:"remaining_seconds"`
}

// Updates the progress percentage and returns the new interpolated position
func (q *Queries) UpdateRouteProgress(ctx context.Context, arg UpdateRouteProgressParams) (UpdateRouteProgressRow, error) {
	row := q.db.QueryRow(ctx, updateRouteProgress, arg.ProgressPercent, arg.UnitID)
	var i UpdateRouteProgressRow
	err := row.Scan(
		&i.UnitID,
		&i.ProgressPercent,
		&i.CurrentLon,
		&i.CurrentLat,
		&i.RemainingMeters,
		&i.RemainingSeconds,
	)
	return i, err
}

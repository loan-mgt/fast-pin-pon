// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: events.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createEvent = `-- name: CreateEvent :one
INSERT INTO events (
    title,
    description,
    report_source,
    address,
    location,
    severity,
    event_type_code
) VALUES (
    $1,
    $2,
    $3,
    $4,
    ST_SetSRID(
        ST_MakePoint(
            $5::double precision,
            $6::double precision
        ),
        4326
    )::geography,
    $7,
    $8
) RETURNING
    id,
    title,
    description,
    report_source,
    address,
    ST_X(location::geometry)::double precision AS longitude,
    ST_Y(location::geometry)::double precision AS latitude,
    severity,
    status,
    event_type_code,
    reported_at,
    updated_at,
    closed_at
`

type CreateEventParams struct {
	Title         string  `json:"title"`
	Description   *string `json:"description"`
	ReportSource  *string `json:"report_source"`
	Address       *string `json:"address"`
	Longitude     float64 `json:"longitude"`
	Latitude      float64 `json:"latitude"`
	Severity      int32   `json:"severity"`
	EventTypeCode string  `json:"event_type_code"`
}

type CreateEventRow struct {
	ID            pgtype.UUID        `json:"id"`
	Title         string             `json:"title"`
	Description   *string            `json:"description"`
	ReportSource  *string            `json:"report_source"`
	Address       *string            `json:"address"`
	Longitude     float64            `json:"longitude"`
	Latitude      float64            `json:"latitude"`
	Severity      int32              `json:"severity"`
	Status        EventStatus        `json:"status"`
	EventTypeCode string             `json:"event_type_code"`
	ReportedAt    pgtype.Timestamptz `json:"reported_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	ClosedAt      pgtype.Timestamptz `json:"closed_at"`
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (CreateEventRow, error) {
	row := q.db.QueryRow(ctx, createEvent,
		arg.Title,
		arg.Description,
		arg.ReportSource,
		arg.Address,
		arg.Longitude,
		arg.Latitude,
		arg.Severity,
		arg.EventTypeCode,
	)
	var i CreateEventRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.ReportSource,
		&i.Address,
		&i.Longitude,
		&i.Latitude,
		&i.Severity,
		&i.Status,
		&i.EventTypeCode,
		&i.ReportedAt,
		&i.UpdatedAt,
		&i.ClosedAt,
	)
	return i, err
}

const createEventLog = `-- name: CreateEventLog :one
INSERT INTO event_logs (
    event_id,
    code,
    actor,
    payload
) VALUES (
    $1, $2, $3, $4
) RETURNING
    id,
    event_id,
    created_at,
    code,
    actor,
    payload
`

type CreateEventLogParams struct {
	EventID pgtype.UUID `json:"event_id"`
	Code    string      `json:"code"`
	Actor   *string     `json:"actor"`
	Payload []byte      `json:"payload"`
}

func (q *Queries) CreateEventLog(ctx context.Context, arg CreateEventLogParams) (EventLog, error) {
	row := q.db.QueryRow(ctx, createEventLog,
		arg.EventID,
		arg.Code,
		arg.Actor,
		arg.Payload,
	)
	var i EventLog
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.CreatedAt,
		&i.Code,
		&i.Actor,
		&i.Payload,
	)
	return i, err
}

const getEvent = `-- name: GetEvent :one
SELECT
    e.id,
    e.title,
    e.description,
    e.report_source,
    e.address,
    ST_X(e.location::geometry)::double precision AS longitude,
    ST_Y(e.location::geometry)::double precision AS latitude,
    e.severity,
    e.status,
    e.event_type_code,
    et.name AS event_type_name,
    et.default_severity,
    et.recommended_unit_types,
    e.reported_at,
    e.updated_at,
    e.closed_at
FROM events e
JOIN event_types et ON et.code = e.event_type_code
WHERE e.id = $1
`

type GetEventRow struct {
	ID                   pgtype.UUID        `json:"id"`
	Title                string             `json:"title"`
	Description          *string            `json:"description"`
	ReportSource         *string            `json:"report_source"`
	Address              *string            `json:"address"`
	Longitude            float64            `json:"longitude"`
	Latitude             float64            `json:"latitude"`
	Severity             int32              `json:"severity"`
	Status               EventStatus        `json:"status"`
	EventTypeCode        string             `json:"event_type_code"`
	EventTypeName        string             `json:"event_type_name"`
	DefaultSeverity      int32              `json:"default_severity"`
	RecommendedUnitTypes []string           `json:"recommended_unit_types"`
	ReportedAt           pgtype.Timestamptz `json:"reported_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	ClosedAt             pgtype.Timestamptz `json:"closed_at"`
}

func (q *Queries) GetEvent(ctx context.Context, id pgtype.UUID) (GetEventRow, error) {
	row := q.db.QueryRow(ctx, getEvent, id)
	var i GetEventRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.ReportSource,
		&i.Address,
		&i.Longitude,
		&i.Latitude,
		&i.Severity,
		&i.Status,
		&i.EventTypeCode,
		&i.EventTypeName,
		&i.DefaultSeverity,
		&i.RecommendedUnitTypes,
		&i.ReportedAt,
		&i.UpdatedAt,
		&i.ClosedAt,
	)
	return i, err
}

const listEventLogs = `-- name: ListEventLogs :many
SELECT
    id,
    event_id,
    created_at,
    code,
    actor,
    payload
FROM event_logs
WHERE event_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListEventLogsParams struct {
	EventID pgtype.UUID `json:"event_id"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

func (q *Queries) ListEventLogs(ctx context.Context, arg ListEventLogsParams) ([]EventLog, error) {
	rows, err := q.db.Query(ctx, listEventLogs, arg.EventID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventLog
	for rows.Next() {
		var i EventLog
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.CreatedAt,
			&i.Code,
			&i.Actor,
			&i.Payload,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEvents = `-- name: ListEvents :many
SELECT
    e.id,
    e.title,
    e.description,
    e.report_source,
    e.address,
    ST_X(e.location::geometry)::double precision AS longitude,
    ST_Y(e.location::geometry)::double precision AS latitude,
    e.severity,
    e.status,
    e.event_type_code,
    et.name AS event_type_name,
    et.default_severity,
    e.reported_at,
    e.updated_at,
    e.closed_at
FROM events e
JOIN event_types et ON et.code = e.event_type_code
ORDER BY e.reported_at DESC
LIMIT $1 OFFSET $2
`

type ListEventsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListEventsRow struct {
	ID              pgtype.UUID        `json:"id"`
	Title           string             `json:"title"`
	Description     *string            `json:"description"`
	ReportSource    *string            `json:"report_source"`
	Address         *string            `json:"address"`
	Longitude       float64            `json:"longitude"`
	Latitude        float64            `json:"latitude"`
	Severity        int32              `json:"severity"`
	Status          EventStatus        `json:"status"`
	EventTypeCode   string             `json:"event_type_code"`
	EventTypeName   string             `json:"event_type_name"`
	DefaultSeverity int32              `json:"default_severity"`
	ReportedAt      pgtype.Timestamptz `json:"reported_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	ClosedAt        pgtype.Timestamptz `json:"closed_at"`
}

func (q *Queries) ListEvents(ctx context.Context, arg ListEventsParams) ([]ListEventsRow, error) {
	rows, err := q.db.Query(ctx, listEvents, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEventsRow
	for rows.Next() {
		var i ListEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.ReportSource,
			&i.Address,
			&i.Longitude,
			&i.Latitude,
			&i.Severity,
			&i.Status,
			&i.EventTypeCode,
			&i.EventTypeName,
			&i.DefaultSeverity,
			&i.ReportedAt,
			&i.UpdatedAt,
			&i.ClosedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEventStatus = `-- name: UpdateEventStatus :one
UPDATE events
SET
    status = $2,
    updated_at = NOW(),
    closed_at = CASE WHEN $2 = 'closed' THEN NOW() ELSE closed_at END
WHERE id = $1
RETURNING
    id,
    title,
    description,
    report_source,
    address,
    ST_X(location::geometry)::double precision AS longitude,
    ST_Y(location::geometry)::double precision AS latitude,
    severity,
    status,
    event_type_code,
    reported_at,
    updated_at,
    closed_at
`

type UpdateEventStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status EventStatus `json:"status"`
}

type UpdateEventStatusRow struct {
	ID            pgtype.UUID        `json:"id"`
	Title         string             `json:"title"`
	Description   *string            `json:"description"`
	ReportSource  *string            `json:"report_source"`
	Address       *string            `json:"address"`
	Longitude     float64            `json:"longitude"`
	Latitude      float64            `json:"latitude"`
	Severity      int32              `json:"severity"`
	Status        EventStatus        `json:"status"`
	EventTypeCode string             `json:"event_type_code"`
	ReportedAt    pgtype.Timestamptz `json:"reported_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	ClosedAt      pgtype.Timestamptz `json:"closed_at"`
}

func (q *Queries) UpdateEventStatus(ctx context.Context, arg UpdateEventStatusParams) (UpdateEventStatusRow, error) {
	row := q.db.QueryRow(ctx, updateEventStatus, arg.ID, arg.Status)
	var i UpdateEventStatusRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.ReportSource,
		&i.Address,
		&i.Longitude,
		&i.Latitude,
		&i.Severity,
		&i.Status,
		&i.EventTypeCode,
		&i.ReportedAt,
		&i.UpdatedAt,
		&i.ClosedAt,
	)
	return i, err
}

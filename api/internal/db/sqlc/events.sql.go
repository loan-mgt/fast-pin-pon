// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: events.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createEvent = `-- name: CreateEvent :one
INSERT INTO events (
    title,
    description,
    report_source,
    address,
    location,
    severity,
    event_type_code
) VALUES (
    $1,
    $2,
    $3,
    $4,
    ST_SetSRID(
        ST_MakePoint(
            $5::double precision,
            $6::double precision
        ),
        4326
    )::geography,
    $7,
    $8
) RETURNING
    id,
    title,
    description,
    report_source,
    address,
    ST_X(location::geometry)::double precision AS longitude,
    ST_Y(location::geometry)::double precision AS latitude,
    severity,
    event_type_code,
    reported_at,
    updated_at,
    closed_at
`

type CreateEventParams struct {
	Title         string  `json:"title"`
	Description   *string `json:"description"`
	ReportSource  *string `json:"report_source"`
	Address       *string `json:"address"`
	Longitude     float64 `json:"longitude"`
	Latitude      float64 `json:"latitude"`
	Severity      int32   `json:"severity"`
	EventTypeCode string  `json:"event_type_code"`
}

type CreateEventRow struct {
	ID            pgtype.UUID        `json:"id"`
	Title         string             `json:"title"`
	Description   *string            `json:"description"`
	ReportSource  *string            `json:"report_source"`
	Address       *string            `json:"address"`
	Longitude     float64            `json:"longitude"`
	Latitude      float64            `json:"latitude"`
	Severity      int32              `json:"severity"`
	EventTypeCode string             `json:"event_type_code"`
	ReportedAt    pgtype.Timestamptz `json:"reported_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	ClosedAt      pgtype.Timestamptz `json:"closed_at"`
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (CreateEventRow, error) {
	row := q.db.QueryRow(ctx, createEvent,
		arg.Title,
		arg.Description,
		arg.ReportSource,
		arg.Address,
		arg.Longitude,
		arg.Latitude,
		arg.Severity,
		arg.EventTypeCode,
	)
	var i CreateEventRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.ReportSource,
		&i.Address,
		&i.Longitude,
		&i.Latitude,
		&i.Severity,
		&i.EventTypeCode,
		&i.ReportedAt,
		&i.UpdatedAt,
		&i.ClosedAt,
	)
	return i, err
}

const createEventLog = `-- name: CreateEventLog :one
INSERT INTO event_logs (
    event_id,
    code,
    actor,
    payload
) VALUES (
    $1, $2, $3, $4
) RETURNING
    id,
    event_id,
    created_at,
    code,
    actor,
    payload
`

type CreateEventLogParams struct {
	EventID pgtype.UUID `json:"event_id"`
	Code    string      `json:"code"`
	Actor   *string     `json:"actor"`
	Payload []byte      `json:"payload"`
}

func (q *Queries) CreateEventLog(ctx context.Context, arg CreateEventLogParams) (EventLog, error) {
	row := q.db.QueryRow(ctx, createEventLog,
		arg.EventID,
		arg.Code,
		arg.Actor,
		arg.Payload,
	)
	var i EventLog
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.CreatedAt,
		&i.Code,
		&i.Actor,
		&i.Payload,
	)
	return i, err
}

const getEvent = `-- name: GetEvent :one
SELECT
    e.id,
    e.title,
    e.description,
    e.report_source,
    e.address,
    ST_X(e.location::geometry)::double precision AS longitude,
    ST_Y(e.location::geometry)::double precision AS latitude,
    e.severity,
    e.event_type_code,
    et.name AS event_type_name,
    et.default_severity,
    et.recommended_unit_types,
    e.reported_at,
    e.updated_at,
    e.closed_at,
    i.id AS intervention_id,
    i.status AS intervention_status
FROM events e
JOIN event_types et ON et.code = e.event_type_code
LEFT JOIN interventions i ON i.event_id = e.id
WHERE e.id = $1
`

type GetEventRow struct {
	ID                   pgtype.UUID            `json:"id"`
	Title                string                 `json:"title"`
	Description          *string                `json:"description"`
	ReportSource         *string                `json:"report_source"`
	Address              *string                `json:"address"`
	Longitude            float64                `json:"longitude"`
	Latitude             float64                `json:"latitude"`
	Severity             int32                  `json:"severity"`
	EventTypeCode        string                 `json:"event_type_code"`
	EventTypeName        string                 `json:"event_type_name"`
	DefaultSeverity      int32                  `json:"default_severity"`
	RecommendedUnitTypes []string               `json:"recommended_unit_types"`
	ReportedAt           pgtype.Timestamptz     `json:"reported_at"`
	UpdatedAt            pgtype.Timestamptz     `json:"updated_at"`
	ClosedAt             pgtype.Timestamptz     `json:"closed_at"`
	InterventionID       pgtype.UUID            `json:"intervention_id"`
	InterventionStatus   NullInterventionStatus `json:"intervention_status"`
}

func (q *Queries) GetEvent(ctx context.Context, id pgtype.UUID) (GetEventRow, error) {
	row := q.db.QueryRow(ctx, getEvent, id)
	var i GetEventRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.ReportSource,
		&i.Address,
		&i.Longitude,
		&i.Latitude,
		&i.Severity,
		&i.EventTypeCode,
		&i.EventTypeName,
		&i.DefaultSeverity,
		&i.RecommendedUnitTypes,
		&i.ReportedAt,
		&i.UpdatedAt,
		&i.ClosedAt,
		&i.InterventionID,
		&i.InterventionStatus,
	)
	return i, err
}

const listEventLogs = `-- name: ListEventLogs :many
SELECT
    id,
    event_id,
    created_at,
    code,
    actor,
    payload
FROM event_logs
WHERE event_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListEventLogsParams struct {
	EventID pgtype.UUID `json:"event_id"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

func (q *Queries) ListEventLogs(ctx context.Context, arg ListEventLogsParams) ([]EventLog, error) {
	rows, err := q.db.Query(ctx, listEventLogs, arg.EventID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventLog
	for rows.Next() {
		var i EventLog
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.CreatedAt,
			&i.Code,
			&i.Actor,
			&i.Payload,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEvents = `-- name: ListEvents :many
SELECT
    e.id,
    e.title,
    e.description,
    e.report_source,
    e.address,
    ST_X(e.location::geometry)::double precision AS longitude,
    ST_Y(e.location::geometry)::double precision AS latitude,
    e.severity,
    e.event_type_code,
    et.name AS event_type_name,
    et.default_severity,
    e.reported_at,
    e.updated_at,
    e.closed_at,
    i.id AS intervention_id,
    i.status AS intervention_status,
    i.started_at AS intervention_started_at,
    i.completed_at AS intervention_completed_at
FROM events e
JOIN event_types et ON et.code = e.event_type_code
LEFT JOIN interventions i ON i.event_id = e.id
ORDER BY e.reported_at DESC
LIMIT $1 OFFSET $2
`

type ListEventsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListEventsRow struct {
	ID                       pgtype.UUID            `json:"id"`
	Title                    string                 `json:"title"`
	Description              *string                `json:"description"`
	ReportSource             *string                `json:"report_source"`
	Address                  *string                `json:"address"`
	Longitude                float64                `json:"longitude"`
	Latitude                 float64                `json:"latitude"`
	Severity                 int32                  `json:"severity"`
	EventTypeCode            string                 `json:"event_type_code"`
	EventTypeName            string                 `json:"event_type_name"`
	DefaultSeverity          int32                  `json:"default_severity"`
	ReportedAt               pgtype.Timestamptz     `json:"reported_at"`
	UpdatedAt                pgtype.Timestamptz     `json:"updated_at"`
	ClosedAt                 pgtype.Timestamptz     `json:"closed_at"`
	InterventionID           pgtype.UUID            `json:"intervention_id"`
	InterventionStatus       NullInterventionStatus `json:"intervention_status"`
	InterventionStartedAt    pgtype.Timestamptz     `json:"intervention_started_at"`
	InterventionCompletedAt  pgtype.Timestamptz     `json:"intervention_completed_at"`
}

func (q *Queries) ListEvents(ctx context.Context, arg ListEventsParams) ([]ListEventsRow, error) {
	rows, err := q.db.Query(ctx, listEvents, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEventsRow
	for rows.Next() {
		var i ListEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.ReportSource,
			&i.Address,
			&i.Longitude,
			&i.Latitude,
			&i.Severity,
			&i.EventTypeCode,
			&i.EventTypeName,
			&i.DefaultSeverity,
			&i.ReportedAt,
			&i.UpdatedAt,
			&i.ClosedAt,
			&i.InterventionID,
			&i.InterventionStatus,
			&i.InterventionStartedAt,
			&i.InterventionCompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentEventLogs = `-- name: ListRecentEventLogs :many
WITH recent_events AS (
    SELECT 
        e.id AS event_id,
        e.title AS event_title,
        e.event_type_code,
        e.reported_at
    FROM events e
    LEFT JOIN interventions i ON i.event_id = e.id
    WHERE e.closed_at IS NULL 
      AND (i.status IS NULL OR i.status NOT IN ('completed', 'cancelled'))
    ORDER BY e.reported_at DESC
    LIMIT $1
),
latest_logs AS (
    SELECT DISTINCT ON (el.event_id)
        el.id,
        el.event_id,
        el.created_at,
        el.code,
        el.actor,
        el.payload
    FROM event_logs el
    WHERE el.event_id IN (SELECT event_id FROM recent_events)
    ORDER BY el.event_id, el.created_at DESC
)
SELECT 
    COALESCE(ll.id, 0) AS id,
    re.event_id,
    COALESCE(ll.created_at, re.reported_at) AS created_at,
    COALESCE(ll.code, 'created') AS code,
    ll.actor,
    COALESCE(ll.payload, '{}'::jsonb) AS payload,
    re.event_title,
    re.event_type_code
FROM recent_events re
LEFT JOIN latest_logs ll ON ll.event_id = re.event_id
ORDER BY re.reported_at DESC
`

type ListRecentEventLogsRow struct {
	ID            int64              `json:"id"`
	EventID       pgtype.UUID        `json:"event_id"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	Code          string             `json:"code"`
	Actor         *string            `json:"actor"`
	Payload       []byte             `json:"payload"`
	EventTitle    string             `json:"event_title"`
	EventTypeCode string             `json:"event_type_code"`
}

func (q *Queries) ListRecentEventLogs(ctx context.Context, limit int32) ([]ListRecentEventLogsRow, error) {
	rows, err := q.db.Query(ctx, listRecentEventLogs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRecentEventLogsRow
	for rows.Next() {
		var i ListRecentEventLogsRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.CreatedAt,
			&i.Code,
			&i.Actor,
			&i.Payload,
			&i.EventTitle,
			&i.EventTypeCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

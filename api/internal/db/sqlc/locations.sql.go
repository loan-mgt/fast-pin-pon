// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: locations.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getNearestStation = `-- name: GetNearestStation :one
SELECT
    id,
    name,
    type,
    (COALESCE(ST_X(location::geometry)::double precision, 0::double precision))::double precision AS longitude,
    (COALESCE(ST_Y(location::geometry)::double precision, 0::double precision))::double precision AS latitude,
    created_at,
    updated_at
FROM locations
WHERE type = 'station'
ORDER BY ST_Distance(
    location,
    ST_SetSRID(ST_MakePoint($1::double precision, $2::double precision), 4326)::geography
) ASC
LIMIT 1
`

type GetNearestStationParams struct {
	Longitude float64 `json:"longitude"`
	Latitude  float64 `json:"latitude"`
}

type GetNearestStationRow struct {
	ID        pgtype.UUID        `json:"id"`
	Name      string             `json:"name"`
	Type      string             `json:"type"`
	Longitude float64            `json:"longitude"`
	Latitude  float64            `json:"latitude"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetNearestStation(ctx context.Context, arg GetNearestStationParams) (GetNearestStationRow, error) {
	row := q.db.QueryRow(ctx, getNearestStation, arg.Longitude, arg.Latitude)
	var i GetNearestStationRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Longitude,
		&i.Latitude,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getStation = `-- name: GetStation :one
SELECT
    id,
    name,
    type,
    (COALESCE(ST_X(location::geometry)::double precision, 0::double precision))::double precision AS longitude,
    (COALESCE(ST_Y(location::geometry)::double precision, 0::double precision))::double precision AS latitude,
    created_at,
    updated_at
FROM locations
WHERE id = $1 AND type = 'station'
`

type GetStationRow struct {
	ID        pgtype.UUID        `json:"id"`
	Name      string             `json:"name"`
	Type      string             `json:"type"`
	Longitude float64            `json:"longitude"`
	Latitude  float64            `json:"latitude"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetStation(ctx context.Context, id pgtype.UUID) (GetStationRow, error) {
	row := q.db.QueryRow(ctx, getStation, id)
	var i GetStationRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Longitude,
		&i.Latitude,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listLocations = `-- name: ListLocations :many
SELECT
    id,
    name,
    type,
    (COALESCE(ST_X(location::geometry)::double precision, 0::double precision))::double precision AS longitude,
    (COALESCE(ST_Y(location::geometry)::double precision, 0::double precision))::double precision AS latitude,
    created_at,
    updated_at
FROM locations
ORDER BY name
`

type ListLocationsRow struct {
	ID        pgtype.UUID        `json:"id"`
	Name      string             `json:"name"`
	Type      string             `json:"type"`
	Longitude float64            `json:"longitude"`
	Latitude  float64            `json:"latitude"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) ListLocations(ctx context.Context) ([]ListLocationsRow, error) {
	rows, err := q.db.Query(ctx, listLocations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListLocationsRow
	for rows.Next() {
		var i ListLocationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.Longitude,
			&i.Latitude,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStations = `-- name: ListStations :many
SELECT
    id,
    name,
    type,
    (COALESCE(ST_X(location::geometry)::double precision, 0::double precision))::double precision AS longitude,
    (COALESCE(ST_Y(location::geometry)::double precision, 0::double precision))::double precision AS latitude,
    created_at,
    updated_at
FROM locations
WHERE type = 'station'
ORDER BY name
`

type ListStationsRow struct {
	ID        pgtype.UUID        `json:"id"`
	Name      string             `json:"name"`
	Type      string             `json:"type"`
	Longitude float64            `json:"longitude"`
	Latitude  float64            `json:"latitude"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) ListStations(ctx context.Context) ([]ListStationsRow, error) {
	rows, err := q.db.Query(ctx, listStations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListStationsRow
	for rows.Next() {
		var i ListStationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.Longitude,
			&i.Latitude,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

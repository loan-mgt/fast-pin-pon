// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: activity_logs.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createActivityLog = `-- name: CreateActivityLog :one
INSERT INTO activity_logs (
    activity_type,
    entity_type,
    entity_id,
    actor,
    old_value,
    new_value,
    metadata
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    COALESCE($7, '{}'::jsonb)
)
RETURNING id, activity_type, entity_type, entity_id, actor, old_value, new_value, created_at, metadata
`

type CreateActivityLogParams struct {
	ActivityType string      `json:"activity_type"`
	EntityType   *string     `json:"entity_type"`
	EntityID     pgtype.UUID `json:"entity_id"`
	Actor        *string     `json:"actor"`
	OldValue     *string     `json:"old_value"`
	NewValue     *string     `json:"new_value"`
	Metadata     interface{} `json:"metadata"`
}

// Insert a new activity log entry
func (q *Queries) CreateActivityLog(ctx context.Context, arg CreateActivityLogParams) (ActivityLog, error) {
	row := q.db.QueryRow(ctx, createActivityLog,
		arg.ActivityType,
		arg.EntityType,
		arg.EntityID,
		arg.Actor,
		arg.OldValue,
		arg.NewValue,
		arg.Metadata,
	)
	var i ActivityLog
	err := row.Scan(
		&i.ID,
		&i.ActivityType,
		&i.EntityType,
		&i.EntityID,
		&i.Actor,
		&i.OldValue,
		&i.NewValue,
		&i.CreatedAt,
		&i.Metadata,
	)
	return i, err
}

const listActivityLogsForEvent = `-- name: ListActivityLogsForEvent :many
SELECT 
    al.id,
    al.activity_type,
    al.entity_type,
    al.entity_id,
    al.actor,
    al.old_value,
    al.new_value,
    al.created_at,
    al.metadata
FROM activity_logs al
LEFT JOIN interventions i ON al.entity_type = 'intervention' AND al.entity_id = i.id
WHERE (al.entity_type = 'event' AND al.entity_id = $1)
   OR (al.entity_type = 'intervention' AND i.event_id = $1)
ORDER BY al.created_at DESC
LIMIT $3 OFFSET $2
`

type ListActivityLogsForEventParams struct {
	EventID pgtype.UUID `json:"event_id"`
	Offset  int32       `json:"offset"`
	Limit   int32       `json:"limit"`
}

func (q *Queries) ListActivityLogsForEvent(ctx context.Context, arg ListActivityLogsForEventParams) ([]ActivityLog, error) {
	rows, err := q.db.Query(ctx, listActivityLogsForEvent, arg.EventID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ActivityLog
	for rows.Next() {
		var i ActivityLog
		if err := rows.Scan(
			&i.ID,
			&i.ActivityType,
			&i.EntityType,
			&i.EntityID,
			&i.Actor,
			&i.OldValue,
			&i.NewValue,
			&i.CreatedAt,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentActivityLogs = `-- name: ListRecentActivityLogs :many
SELECT 
    al.id,
    al.activity_type,
    al.entity_type,
    al.entity_id,
    al.actor,
    al.old_value,
    al.new_value,
    al.created_at,
    al.metadata,
    u.call_sign AS unit_call_sign,
    e.title AS event_title,
    i.event_id
FROM activity_logs al
LEFT JOIN units u ON al.entity_type = 'unit' AND al.entity_id = u.id
LEFT JOIN interventions i ON al.entity_type = 'intervention' AND al.entity_id = i.id
LEFT JOIN events e ON i.event_id = e.id
WHERE ($1::text IS NULL OR al.activity_type = $1)
ORDER BY al.created_at DESC
LIMIT $2
`

type ListRecentActivityLogsParams struct {
	ActivityType *string `json:"activity_type"`
	Limit        int32   `json:"limit"`
}

type ListRecentActivityLogsRow struct {
	ID           int64              `json:"id"`
	ActivityType string             `json:"activity_type"`
	EntityType   *string            `json:"entity_type"`
	EntityID     pgtype.UUID        `json:"entity_id"`
	Actor        *string            `json:"actor"`
	OldValue     *string            `json:"old_value"`
	NewValue     *string            `json:"new_value"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	Metadata     []byte             `json:"metadata"`
	UnitCallSign *string            `json:"unit_call_sign"`
	EventTitle   *string            `json:"event_title"`
	EventID      pgtype.UUID        `json:"event_id"`
}

// Fetch recent activity logs with enriched data (join with units and events for call_sign/title)
func (q *Queries) ListRecentActivityLogs(ctx context.Context, arg ListRecentActivityLogsParams) ([]ListRecentActivityLogsRow, error) {
	rows, err := q.db.Query(ctx, listRecentActivityLogs, arg.ActivityType, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRecentActivityLogsRow
	for rows.Next() {
		var i ListRecentActivityLogsRow
		if err := rows.Scan(
			&i.ID,
			&i.ActivityType,
			&i.EntityType,
			&i.EntityID,
			&i.Actor,
			&i.OldValue,
			&i.NewValue,
			&i.CreatedAt,
			&i.Metadata,
			&i.UnitCallSign,
			&i.EventTitle,
			&i.EventID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
